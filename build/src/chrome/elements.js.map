{"version":3,"sources":["../../../src/chrome/elements.js"],"names":["instance","DOM","getDocument","documentResponse","rootId","root","nodeId","getDocumentRootId","selector","querySelector","queryResponse","selectedNodeId","getNodeId","options","CSS","close","Error","getMatchedStylesForNode","includeInherited","matchedStylesResponse","matchedCSSRules","filteredRuleMatches","filter","keepRuleMatch","bind","getElementStyles","rm","selectorList","rule","selectors","origin","startsWithLetter","maxRuleSelectors","maxRuleSelectorsForReset","exclude","length","some","s","text","every","test"],"mappings":";;;;;;;uDAEO,iBAAkCA,QAAlC;AAAA;AAAA;AAAA;AAAA;AAAA;AACGC,eADH,GACWD,QADX,CACGC,GADH;;AAGL;;AAHK;AAAA,mBAIkCA,IAAIC,WAAJ,EAJlC;;AAAA;AAICC,4BAJD;AAKCC,kBALD,GAKkBD,iBAAiBE,IAAjB,CAAsBC,MALxC;AAAA,6CAOEF,MAPF;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,G;;kBAAeG,iB;;;;;AAUtB;;;;;;;;;;wDAOO,kBAA0BP,QAA1B,EAA4CI,MAA5C,EAA4DI,QAA5D;AAAA;AAAA;AAAA;AAAA;AAAA;AACGP,eADH,GACWD,QADX,CACGC,GADH;;AAGL;;AAHK;AAAA,mBAI+BA,IAAIQ,aAAJ,CAAkB;AACpDH,sBAAQF,MAD4C;AAEpDI;AAFoD,aAAlB,CAJ/B;;AAAA;AAICE,yBAJD;AAQCC,0BARD,GAQ0BD,cAAcJ,MARxC;AAAA,8CAUEK,cAVF;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,G;;kBAAeC,S;;;;;AAatB;;;;;;;;AAgCA;;;;;;;;wDAOO,kBAAiCZ,QAAjC,EAAmDI,MAAnD,EAAmES,OAAnE;AAAA;AAAA;AAAA;AAAA;AAAA;AACGC,eADH,GACWd,QADX,CACGc,GADH;AAIGN,oBAJH,GAIgBK,OAJhB,CAIGL,QAJH;;AAML;;AANK;AAAA,mBAOwBI,UAAUZ,QAAV,EAAoBI,MAApB,EAA4BI,QAA5B,CAPxB;;AAAA;AAOCF,kBAPD;;AAAA,kBAUDA,WAAW,CAVV;AAAA;AAAA;AAAA;;AAWHN,qBAASe,KAAT;AAXG,kBAYG,IAAIC,KAAJ,CAAU,4BAAV,CAZH;;AAAA;AAAA;AAAA,mBAgBuCF,IAAIG,uBAAJ,CAA4B;AACtEX,4BADsE;AAEtEY,gCAAkB;AAFoD,aAA5B,CAhBvC;;AAAA;AAgBCC,iCAhBD;;;AAqBL;AAEEC,2BAvBG,GA4BDD,qBA5BC,CAuBHC,eAvBG;;AA8BL;;;;;;;AAMMC,+BApCD,GAoCoCD,gBAAgBE,MAAhB,CAAuBC,cAAcC,IAAd,CAAmB,IAAnB,EAAyBX,OAAzB,CAAvB,CApCpC;AAAA,8CAsCEQ,mBAtCF;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,G;;kBAAeI,gB;;;;;;;AAjCtB,SAASF,aAAT,CAAwBV,OAAxB,EAAyCa,EAAzC,EAAiE;AAC/D,MAAMC,eAA6BD,GAAGE,IAAH,CAAQD,YAA3C;AACA,MAAME,YAAqBF,aAAaE,SAAxC;;AAEA,MAAMC,SAA2BJ,GAAGE,IAAH,CAAQE,MAAzC;AACA,MAAMC,mBAA2B,QAAjC;;AAEA,MAAMC,mBAA2BnB,QAAQmB,gBAAzC;AACA,MAAMC,2BAAmC,CAAzC;;AAEA;;;;;;;AAOA,MAAMC,UAAUJ,WAAW,YAAX,IACXD,UAAUM,MAAV,GAAmBH,gBADR,IAEXH,UAAUO,IAAV,CAAe;AAAA,WAAKC,EAAEC,IAAF,KAAW,GAAhB;AAAA,GAAf,CAFW,IAGVT,UAAUM,MAAV,GAAmBF,wBAAnB,IACGJ,UAAUU,KAAV,CAAgB;AAAA,WAAKR,iBAAiBS,IAAjB,CAAsBH,EAAEC,IAAxB,CAAL;AAAA,GAAhB,CAJT;;AAMA,SAAO,CAACJ,OAAR;AACD","file":"elements.js","sourcesContent":["// @flow\n\nexport async function getDocumentRootId (instance: Object): Promise<number> {\n  const { DOM } = instance;\n\n  // Get nodeId of document root\n  const documentResponse: Object = await DOM.getDocument();\n  const rootId: number = documentResponse.root.nodeId;\n\n  return rootId;\n}\n\n/**\n * Get the nodeId of the node matching the given selector.\n * @param  {ChromeRemoteInterface} instance\n * @param  {number}                rootId\n * @param  {string}                selector\n * @return {number}                nodeId\n */\nexport async function getNodeId (instance: Object, rootId: number, selector: string): Promise<number> {\n  const { DOM } = instance;\n\n  // Get nodeId of selected element\n  const queryResponse: Object = await DOM.querySelector({\n    nodeId: rootId,\n    selector,\n  });\n  const selectedNodeId: number = queryResponse.nodeId;\n\n  return selectedNodeId;\n}\n\n/**\n * Predicate to filter out RuleMatch objects.\n * @param  {Object} options  contains options for filtering\n * @param  {RuleMatch} rm    a RuleMatch object\n * @return {boolean}         whether to keep the RuleMatch\n */\nfunction keepRuleMatch (options: Object, rm: RuleMatch): boolean {\n  const selectorList: SelectorList = rm.rule.selectorList;\n  const selectors: Value[] = selectorList.selectors;\n\n  const origin: StyleSheetOrigin = rm.rule.origin;\n  const startsWithLetter: RegExp = /^[a-z]/;\n\n  const maxRuleSelectors: number = options.maxRuleSelectors;\n  const maxRuleSelectorsForReset: number = 3;\n\n  /**\n   * Disregard rules if any of the following are true:\n   * - origin is the user-agent\n   * - exceeds the specified upper bound of selectors (probably a reset)\n   * - global selector (*) is used\n   * - > 3 selectors, all beginning with a letter (probably a reset)\n   */\n  const exclude = origin === 'user-agent'\n    || selectors.length > maxRuleSelectors\n    || selectors.some(s => s.text === '*')\n    || (selectors.length > maxRuleSelectorsForReset\n        && selectors.every(s => startsWithLetter.test(s.text)));\n\n  return !exclude;\n}\n\n/**\n * Get the matched styles for an element corresponding to a nodeId.\n * @param  {Object} instance chrome-remote-interface session\n * @param  {number} rootId   nodeId of root node\n * @param  {Object} options  options object\n * @return {RuleMatch}\n */\nexport async function getElementStyles (instance: Object, rootId: number, options: Object): Promise<RuleMatch[]> {\n  const { CSS } = instance;\n\n\n  const { selector } = options;\n\n  // Get the nodeId of the element matching the selector\n  const nodeId: number = await getNodeId(instance, rootId, selector);\n\n  // Handle the case where the element is not returned\n  if (nodeId === 0) {\n    instance.close();\n    throw new Error('Selected element not found');\n  }\n\n  // Get all matched styles for node\n  const matchedStylesResponse: Object = await CSS.getMatchedStylesForNode({\n    nodeId,\n    includeInherited: false,\n  });\n\n  // Extract only the parts we care about from the matched styles response\n  const {\n    matchedCSSRules,\n    // pseudoElements,\n    // cssKeyframesRules,\n  }: {\n    matchedCSSRules: RuleMatch[],\n  } = matchedStylesResponse;\n\n  /**\n   * Disregard rules if any of the following are true:\n   * - origin is the user-agent\n   * - global selector (*) is used\n   * - exceeds the specified upper bound of selectors (probably a reset)\n   */\n  const filteredRuleMatches: RuleMatch[] = matchedCSSRules.filter(keepRuleMatch.bind(null, options));\n\n  return filteredRuleMatches;\n}\n"]}