{"version":3,"sources":["../../src/screenshot.js"],"names":["instance","Page","captureScreenshot","response","data","fileToPNG","filePath","Promise","resolve","reject","png","createReadStream","pipe","on","err","stringToPNG","bufferStream","end","Buffer","writeScreenshot","screenshotFilePath","outputPath","__dirname","pack","createWriteStream","writeToDisk","delay","timeout","ms","setTimeout","shotString","shotPNG","screenshotPage"],"mappings":";;;;;;AAiDA;;;;uDAGA,iBAAkCA,QAAlC;AAAA;AAAA;AAAA;AAAA;AAAA;AACUC,gBADV,GACmBD,QADnB,CACUC,IADV;AAAA;AAAA,mBAG8BA,KAAKC,iBAAL,EAH9B;;AAAA;AAGQC,oBAHR;AAIQC,gBAJR,GAIuBD,SAASC,IAJhC;AAAA,6CAMSA,IANT;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,G;;kBAAeF,iB;;;;;AASf;;;;;;;;;AA5DA;;;;AACA;;;;AACA;;AACA;;;;;;AAEA;;;;;AAKA,SAASG,SAAT,CAAoBC,QAApB,EAAoD;AAClD,SAAO,IAAIC,OAAJ,CAAY,UAACC,OAAD,EAAUC,MAAV,EAAqB;AACtC,QAAMC,MAAM,aAAGC,gBAAH,CAAoBL,QAApB,EAA8BM,IAA9B,CAAmC,gBAAnC,CAAZ;;AAEAF,QAAIG,EAAJ,CAAO,OAAP,EAAgB,UAACC,GAAD,EAAS;AAAE,aAAOL,OAAOK,GAAP,CAAP;AAAoB,KAA/C;AACAJ,QAAIG,EAAJ,CAAO,QAAP,EAAiB,YAAM;AAAEL,cAAQE,GAAR;AAAc,KAAvC;AACD,GALM,CAAP;AAMD;;AAED;;;;;AAKA,SAASK,WAAT,CAAsBX,IAAtB,EAAkD;AAChD,SAAO,IAAIG,OAAJ,CAAY,UAACC,OAAD,EAAUC,MAAV,EAAqB;AACtC;AACA,QAAMO,eAAe,yBAArB;AACAA,iBAAaC,GAAb,CAAiB,IAAIC,MAAJ,CAAWd,IAAX,EAAiB,QAAjB,CAAjB;;AAEA,QAAMM,MAAMM,aAAaJ,IAAb,CAAkB,gBAAlB,CAAZ;AACAF,QAAIG,EAAJ,CAAO,OAAP,EAAgB,UAACC,GAAD,EAAS;AAAE,aAAOL,OAAOK,GAAP,CAAP;AAAoB,KAA/C;AACAJ,QAAIG,EAAJ,CAAO,QAAP,EAAiB,YAAM;AAAEL,cAAQE,GAAR;AAAc,KAAvC;AACD,GARM,CAAP;AASD;;AAED;;;;;;AAMA,SAASS,eAAT,CAA0BC,kBAA1B,EAAsDhB,IAAtD,EAAuE;AACrE,MAAMiB,aAAa,eAAKb,OAAL,CAAac,SAAb,EAAwB,KAAxB,EAA+BF,kBAA/B,CAAnB;;AAEAhB,OAAKmB,IAAL,GAAYX,IAAZ,CAAiB,aAAGY,iBAAH,CAAqBH,UAArB,CAAjB;AACD;;wDAqBc,kBAA+BrB,QAA/B;AAAA,QAAiDyB,WAAjD,uEAAwE,KAAxE;AAAA,QAA+EL,kBAA/E;AAAA,QAA4GM,KAA5G;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,iBACTA,KADS;AAAA;AAAA;AAAA;;AAELC,mBAFK,GAEK,SAAVA,OAAU,CAACC,EAAD;AAAA,qBAAQ,IAAIrB,OAAJ,CAAY;AAAA,uBAAWsB,WAAWrB,OAAX,EAAoBoB,EAApB,CAAX;AAAA,eAAZ,CAAR;AAAA,aAFL;;AAAA;AAAA,mBAGLD,QAAQD,KAAR,CAHK;;AAAA;AAAA;AAAA,mBAMoBxB,kBAAkBF,QAAlB,CANpB;;AAAA;AAMP8B,sBANO;AAAA;AAAA,mBAOcf,YAAYe,UAAZ,CAPd;;AAAA;AAOPC,mBAPO;;;AASb,gBAAIN,WAAJ,EAAiB;AACfN,8BAAgBC,kBAAhB,EAAoCW,OAApC;AACD;;AAXY,8CAaNA,OAbM;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,G;;WAAeC,c;;;;SAAAA,c","file":"screenshot.js","sourcesContent":["// @flow\nimport fs from 'fs';\nimport path from 'path';\nimport { PassThrough } from 'stream';\nimport { PNG } from 'pngjs';\n\n/**\n * Reads a file at the specified path, and converts it into a PNG object.\n * @param  {string} filePath        path to the PNG file on disk\n * @return {Promise<PNG>}           parsed PNG object\n */\nfunction fileToPNG (filePath: string): Promise<PNG> {\n  return new Promise((resolve, reject) => {\n    const png = fs.createReadStream(filePath).pipe(new PNG());\n\n    png.on('error', (err) => { return reject(err) });\n    png.on('parsed', () => { resolve(png) });\n  });\n}\n\n/**\n * Converts PNG image data in b64 format into a PNG object.\n * @param  {string} data            b64 PNG image data\n * @return {Promise<PNG>}           parsed PNG object\n */\nfunction stringToPNG (data: string): Promise<PNG> {\n  return new Promise((resolve, reject) => {\n    // Initiate the source\n    const bufferStream = new PassThrough();\n    bufferStream.end(new Buffer(data, 'base64'));\n\n    const png = bufferStream.pipe(new PNG());\n    png.on('error', (err) => { return reject(err) });\n    png.on('parsed', () => { resolve(png) });\n  });\n}\n\n/**\n * Writes a screenshot in PNG form to disk.\n * @param  {string} screenshotFilePath   output path for screenshot\n * @param  {string} data                 image data in PNG form\n * @return {void}\n */\nfunction writeScreenshot (screenshotFilePath: string, data: PNG): void {\n  const outputPath = path.resolve(__dirname, '../', screenshotFilePath);\n\n  data.pack().pipe(fs.createWriteStream(outputPath));\n}\n\n/**\n * Utility function to capture the screenshot of the current page state.\n */\nasync function captureScreenshot (instance: Object): Promise<string> {\n  const { Page } = instance;\n\n  const response: any = await Page.captureScreenshot();\n  const data: string = response.data;\n\n  return data;\n}\n\n/**\n * Captures a screenshot of the current page state, optionally delaying\n * by a specified number of milliseconds.\n *\n * Returns a Promise which resolves to a string of the data.\n * TODO: Streamify this.\n */\nexport default async function screenshotPage (instance: Object, writeToDisk: boolean = false, screenshotFilePath?: string, delay?: number): Promise<PNG> {\n  if (delay) {\n    const timeout = (ms) => new Promise(resolve => setTimeout(resolve, ms));\n    await timeout(delay);\n  }\n\n  const shotString: string = await captureScreenshot(instance);\n  const shotPNG: PNG = await stringToPNG(shotString);\n\n  if (writeToDisk) {\n    writeScreenshot(screenshotFilePath, shotPNG);\n  }\n\n  return shotPNG;\n}\n"]}