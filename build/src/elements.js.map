{"version":3,"sources":["../../src/elements.js"],"names":["getDocumentRootId","getNodeId","getElementStyles","instance","DOM","getDocument","documentResponse","rootId","root","nodeId","selector","querySelector","queryResponse","selectedNodeId","keepRuleMatch","options","rm","selectorList","rule","origin","maxRuleSelectors","exclude","selectors","length","some","text","CSS","getMatchedStylesForNode","includeInherited","matchedStylesResponse","matchedCSSRules","filteredRuleMatches","filter","bind"],"mappings":";;;;;QAIgBA,iB,GAAAA,iB;QAmBAC,S,GAAAA,S;QA8CAC,gB,GAAAA,gB;;AApEhB;;;;AACA;;;;AAEO,SAASF,iBAAT,CAA4BG,QAA5B,EAA+D;AACpE,SAAO,0CAAG;AAAA;AAAA;AAAA;AAAA;AAAA;AACAC,eADA,GACQD,QADR,CACAC,GADA;;AAGR;;AAHQ;AAAA,mBAI+BA,IAAIC,WAAJ,EAJ/B;;AAAA;AAIFC,4BAJE;AAKFC,kBALE,GAKeD,iBAAiBE,IAAjB,CAAsBC,MALrC;AAAA,6CAODF,MAPC;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,GAAH,EAAP;AASD;;AAED;;;;;;;AAOO,SAASN,SAAT,CAAoBE,QAApB,EAAsCI,MAAtC,EAAsDG,QAAtD,EAAyF;AAC9F,SAAO,0CAAG;AAAA;AAAA;AAAA;AAAA;AAAA;AACAN,eADA,GACQD,QADR,CACAC,GADA;;AAGR;;AAHQ;AAAA,mBAI4BA,IAAIO,aAAJ,CAAkB;AACpDF,sBAAQF,MAD4C;AAEpDG;AAFoD,aAAlB,CAJ5B;;AAAA;AAIFE,yBAJE;AAQFC,0BARE,GAQuBD,cAAcH,MARrC;AAAA,8CAUDI,cAVC;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,GAAH,EAAP;AAYD;;AAED;;;;;;AAMA,SAASC,aAAT,CAAwBC,OAAxB,EAAyCC,EAAzC,EAAiE;AAC/D,MAAMC,eAA6BD,GAAGE,IAAH,CAAQD,YAA3C;AACA,MAAME,SAA2BH,GAAGE,IAAH,CAAQC,MAAzC;AACA,MAAMC,mBAA2BL,QAAQK,gBAAzC;;AAEA;;;;;;AAMA,MAAMC,UAAUF,WAAW,YAAX,IACXF,aAAaK,SAAb,CAAuBC,MAAvB,GAAgCH,gBADrB,IAEXH,aAAaK,SAAb,CAAuBE,IAAvB,CAA4B,UAACd,QAAD;AAAA,WAAcA,SAASe,IAAT,KAAkB,GAAhC;AAAA,GAA5B,CAFL;;AAIA,SAAO,CAACJ,OAAR;AACD;;AAED;;;;;;;AAOO,SAASnB,gBAAT,CAA2BC,QAA3B,EAA6CI,MAA7C,EAA6DQ,OAA7D,EAAoG;AACzG,SAAO,0CAAG;AAAA;AAAA;AAAA;AAAA;AAAA;AACAW,eADA,GACQvB,QADR,CACAuB,GADA;AAIAhB,oBAJA,GAIaK,OAJb,CAIAL,QAJA;;AAMR;;AANQ;AAAA,mBAOqBT,UAAUE,QAAV,EAAoBI,MAApB,EAA4BG,QAA5B,CAPrB;;AAAA;AAOFD,kBAPE;AAAA;AAAA,mBAUoCiB,IAAIC,uBAAJ,CAA4B;AACtElB,4BADsE;AAEtEmB,gCAAkB;AAFoD,aAA5B,CAVpC;;AAAA;AAUFC,iCAVE;;;AAeR;AAEEC,2BAjBM,GAsBJD,qBAtBI,CAiBNC,eAjBM;;AAwBR;;;;;;;AAMMC,+BA9BE,GA8BiCD,gBAAgBE,MAAhB,CAAuBlB,cAAcmB,IAAd,CAAmB,IAAnB,EAAyBlB,OAAzB,CAAvB,CA9BjC;AAAA,8CAgCDgB,mBAhCC;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,GAAH,EAAP;AAkCD","file":"elements.js","sourcesContent":["// @flow\nimport co from 'co';\nimport { applyPseudoStates } from './preparePage';\n\nexport function getDocumentRootId (instance: Object): Promise<number> {\n  return co(function* () {\n    const { DOM } = instance;\n\n    // Get nodeId of document root\n    const documentResponse: Object = yield DOM.getDocument();\n    const rootId: number = documentResponse.root.nodeId;\n\n    return rootId;\n  });\n}\n\n/**\n * Get the nodeId of the node matching the given selector.\n * @param  {ChromeRemoteInterface} instance\n * @param  {number}                rootId\n * @param  {string}                selector\n * @return {number}                nodeId\n */\nexport function getNodeId (instance: Object, rootId: number, selector: string): Promise<number> {\n  return co(function* () {\n    const { DOM } = instance;\n\n    // Get nodeId of selected element\n    const queryResponse: Object = yield DOM.querySelector({\n      nodeId: rootId,\n      selector,\n    });\n    const selectedNodeId: number = queryResponse.nodeId;\n\n    return selectedNodeId;\n  });\n}\n\n/**\n * Predicate to filter out RuleMatch objects.\n * @param  {Object} options  contains options for filtering\n * @param  {RuleMatch} rm    a RuleMatch object\n * @return {boolean}         whether to keep the RuleMatch\n */\nfunction keepRuleMatch (options: Object, rm: RuleMatch): boolean {\n  const selectorList: SelectorList = rm.rule.selectorList;\n  const origin: StyleSheetOrigin = rm.rule.origin;\n  const maxRuleSelectors: number = options.maxRuleSelectors;\n\n  /**\n   * Disregard rules if any of the following are true:\n   * - origin is the user-agent\n   * - global selector (*) is used\n   * - exceeds the specified upper bound of selectors (probably a reset)\n   */\n  const exclude = origin === 'user-agent'\n    || selectorList.selectors.length > maxRuleSelectors\n    || selectorList.selectors.some((selector) => selector.text === '*');\n\n  return !exclude;\n}\n\n/**\n * Get the matched styles for an element corresponding to a nodeId.\n * @param  {Object} instance chrome-remote-interface session\n * @param  {number} rootId   nodeId of root node\n * @param  {Object} options  options object\n * @return {RuleMatch}\n */\nexport function getElementStyles (instance: Object, rootId: number, options: Object): Promise<RuleMatch[]> {\n  return co(function* () {\n    const { CSS } = instance;\n\n\n    const { selector } = options;\n\n    // Get the nodeId of the element matching the selector\n    const nodeId: number = yield getNodeId(instance, rootId, selector);\n\n    // Get all matched styles for node\n    const matchedStylesResponse: Object = yield CSS.getMatchedStylesForNode({\n      nodeId,\n      includeInherited: false,\n    });\n\n    // Extract only the parts we care about from the matched styles response\n    const {\n      matchedCSSRules,\n      // pseudoElements,\n      // cssKeyframesRules,\n    }: {\n      matchedCSSRules: RuleMatch[],\n    } = matchedStylesResponse;\n\n    /**\n     * Disregard rules if any of the following are true:\n     * - origin is the user-agent\n     * - global selector (*) is used\n     * - exceeds the specified upper bound of selectors (probably a reset)\n     */\n    const filteredRuleMatches: RuleMatch[] = matchedCSSRules.filter(keepRuleMatch.bind(null, options));\n\n    return filteredRuleMatches;\n  });\n}\n"]}