{"version":3,"sources":["../../index.js"],"names":["require","sourceMaps","OPTIONS","host","port","maxRuleSelectors","verbose","screenshotDir","writeScreenshots","url","selector","pseudoStatesToForce","forcePseudoClasses","then","chrome","Network","Page","DOM","CSS","mainFunction","bind","loadEventFired","enable","on","message","console","log","params","once","navigate","catch","err","error"],"mappings":";;AAGA;;;;AACA;;;;;;AAJAA,QAAQ,gBAAR,EAA0B;AACxBC,cAAY;AADY,CAA1B;;;AAMA;;;;;AAKA,IAAMC,UAAU;AACd;AACAC,QAAM,WAFQ;AAGdC,QAAM,IAHQ;;AAKd;AACAC,oBAAkB,EANJ;;AAQd;AACAC,WAAS,KATK;AAUdC,iBAAe,aAVD;AAWdC,oBAAkB,KAXJ;;AAad;AACA;;AAEA;AACA;;AAEAC,OAAK,mFAnBS;AAoBdC,YAAU,iHApBI;AAqBdC,uBAAqB,CAAC;AACpBD,cAAU,iFADU;AAEpBE,wBAAoB,CAAC,OAAD;AAFA,GAAD;AArBP,CAAhB;;AA2BA,qCAAOV,OAAP;AACE;AACA;AAFF,CAGGW,IAHH,CAGQ,UAACC,MAAD,EAAY;AAAA,MACRC,OADQ,GACoBD,MADpB,CACRC,OADQ;AAAA,MACCC,IADD,GACoBF,MADpB,CACCE,IADD;AAAA,MACOC,GADP,GACoBH,MADpB,CACOG,GADP;AAAA,MACYC,GADZ,GACoBJ,MADpB,CACYI,GADZ;;AAGhB;;;;;;;;AAOA,MAAMC,eAAe,eAAKC,IAAL,CAAU,IAAV,EAAgBN,MAAhB,EAAwBZ,OAAxB,CAArB;AACAc,OAAKK,cAAL,CAAoBF,YAApB;;AAEA;;;AAGAH,OAAKM,MAAL;AACAL,MAAIK,MAAJ;AACAJ,MAAII,MAAJ;;AAEA;;;;AAIA,MAAIpB,QAAQI,OAAZ,EAAqB;AACnBS,YAAQO,MAAR;;AAEAR,WAAOS,EAAP,CAAU,OAAV,EAAmB,UAACC,OAAD,EAAa;AAC9BC,cAAQC,GAAR,CAAYF,QAAQG,MAApB;AACD,KAFD;AAGD;;AAEDb,SAAOc,IAAP,CAAY,OAAZ,EAAqB,YAAM;AAAA,QACjBnB,GADiB,GACTP,OADS,CACjBO,GADiB;;;AAGzBO,SAAKa,QAAL,CAAc,EAAEpB,QAAF,EAAd;AACD,GAJD;AAKD,CAxCH,EAyCGqB,KAzCH,CAyCS,UAACC,GAAD,EAAS;AACdN,UAAQO,KAAR,CAAc,2BAAd,EAA2CD,GAA3C;AACD,CA3CH","file":"index.js","sourcesContent":["require('babel-register')({\n  sourceMaps: true\n});\nimport Chrome from 'chrome-remote-interface';\nimport main from './src/main';\n\n/**\n * Driver wrapper for Chrome Remote Debugging Protocol.\n * Expects an inspectable instance of Chrome running (use `npm run chrome`).\n */\n\nconst OPTIONS = {\n  // Chrome instance to attach to\n  host: 'localhost',\n  port: 9222,\n\n  // How many CSS selectors to allow (used to filter out resets, etc.)\n  maxRuleSelectors: 50,\n\n  // Output and logging options\n  verbose: false,\n  screenshotDir: 'screenshots',\n  writeScreenshots: false,\n\n  // url: 'http://jsbin.com/lutuqe',\n  // selector: '.test-element',\n\n  // url: 'http://tumblr.com',\n  // selector: '.login-section',\n\n  url: 'file:///Users/sarah/git/chrome-pdiff/examples/TooltipStylesInspiration/index.html',\n  selector: 'body > div > div.content > div > p:nth-child(1) > span.tooltip.tooltip-effect-1 > span.tooltip-content.clearfix',\n  pseudoStatesToForce: [{\n    selector: 'body > div > div.content > div > p:nth-child(1) > span.tooltip.tooltip-effect-1',\n    forcePseudoClasses: ['hover'],\n  }],\n};\n\nChrome(OPTIONS)\n  // After defining a new tab, need to initialize a connection\n  // .then((chrome) => Chrome(OPTIONS))\n  .then((chrome) => {\n    const { Network, Page, DOM, CSS } = chrome;\n\n    /**\n     * Call main function on page load. Syntax is short for:\n     *\n     * chrome.on('Page.loadEventFired', (params) => {\n     *   main(chrome, OPTIONS);\n     * });\n     */\n    const mainFunction = main.bind(null, chrome, OPTIONS);\n    Page.loadEventFired(mainFunction);\n\n    /**\n     * Enable domain agents for the protocol instance\n     */\n    Page.enable();\n    DOM.enable();\n    CSS.enable();\n\n    /**\n     * This will log every network request made, so we disable unless\n     * verbose option is true.\n     */\n    if (OPTIONS.verbose) {\n      Network.enable();\n\n      chrome.on('event', (message) => {\n        console.log(message.params);\n      });\n    }\n\n    chrome.once('ready', () => {\n      const { url } = OPTIONS;\n\n      Page.navigate({ url });\n    });\n  })\n  .catch((err) => {\n    console.error('Cannot connect to Chrome:', err);\n  });\n"]}