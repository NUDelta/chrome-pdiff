{"version":3,"sources":["../../../src/screenshot.js"],"names":["screenshotPage","fileToPNG","filePath","Promise","resolve","reject","png","createReadStream","pipe","on","err","stringToPNG","data","bufferStream","end","Buffer","writeScreenshot","screenshotFilePath","outputPath","__dirname","pack","createWriteStream","captureScreenshot","instance","Page","response","writeToDisk","delay","setTimeout","then","catch","shotString","shotPNG"],"mappings":"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","file":"screenshot.js","sourcesContent":["// @flow\nimport fs from 'fs';\nimport path from 'path';\nimport { PassThrough } from 'stream';\nimport co from 'co';\nimport { PNG } from 'pngjs';\n\n/**\n * Reads a file at the specified path, and converts it into a PNG object.\n * @param  {string} filePath        path to the PNG file on disk\n * @return {Promise<PNG>}           parsed PNG object\n */\nfunction fileToPNG (filePath: string): Promise<PNG> {\n  return new Promise((resolve, reject) => {\n    const png = fs.createReadStream(filePath).pipe(new PNG());\n\n    png.on('error', (err) => { return reject(err) });\n    png.on('parsed', () => { resolve(png) });\n  });\n}\n\n/**\n * Converts PNG image data in b64 format into a PNG object.\n * @param  {string} data            b64 PNG image data\n * @return {Promise<PNG>}           parsed PNG object\n */\nfunction stringToPNG (data: string): Promise<PNG> {\n  return new Promise((resolve, reject) => {\n    // Initiate the source\n    const bufferStream = new PassThrough();\n    bufferStream.end(new Buffer(data, 'base64'));\n\n    const png = bufferStream.pipe(new PNG());\n    png.on('error', (err) => { return reject(err) });\n    png.on('parsed', () => { resolve(png) });\n  });\n}\n\n/**\n * Writes a screenshot in PNG form to disk.\n * @param  {string} screenshotFilePath   output path for screenshot\n * @param  {string} data                 image data in PNG form\n * @return {void}\n */\nfunction writeScreenshot (screenshotFilePath: string, data: PNG): void {\n  const outputPath = path.resolve(__dirname, '../', screenshotFilePath);\n\n  data.pack().pipe(fs.createWriteStream(outputPath));\n}\n\n/**\n * Utility function to capture the screenshot of the current page state.\n */\nfunction captureScreenshot (instance: Object): Promise<string> {\n  return co(function* () {\n    const { Page } = instance;\n\n    const response: any = yield Page.captureScreenshot();\n    const data: string = response.data;\n\n    return data;\n  });\n}\n\n/**\n * Captures a screenshot of the current page state, optionally delaying\n * by a specified number of milliseconds.\n *\n * Returns a Promise which resolves to a string of the data.\n * TODO: Streamify this.\n */\nexport default function screenshotPage (instance: Object, writeToDisk: boolean = false, screenshotFilePath?: string, delay?: number): Promise<PNG> {\n  return co(function* () {\n    if (delay) {\n      return new Promise((resolve, reject) => {\n        setTimeout(() => {\n          captureScreenshot(instance)\n            .then(stringToPNG)\n            .then((png) => {\n              if (writeToDisk) {\n                writeScreenshot(screenshotFilePath, png);\n              }\n\n              resolve(png);\n            })\n            .catch((err) => reject(err));\n        }, delay);\n      });\n    }\n\n    const shotString: string = yield captureScreenshot(instance);\n    const shotPNG: PNG = yield stringToPNG(shotString);\n\n    if (writeToDisk) {\n      writeScreenshot(screenshotFilePath, shotPNG);\n    }\n\n    return shotPNG;\n  });\n}\n"]}