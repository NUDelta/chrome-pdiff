{"version":3,"sources":["../index.js"],"names":[],"mappings":";;AACA;;AACA;;;;AACA;;AACA;;;;;;AAEA;AACA,IAAM,OAAiB,cAAM,CAAN,CAAvB;AACA,IAAM,cAAsB,OAAO,MAAP,CAAc,EAAd,qBAA6B,IAA7B,CAA5B;;AAEA;;;;;AAKA,SAAS,IAAT,CAAe,OAAf,EAAwB,MAAxB,EAAgC;AAAA,MACtB,IADsB,GACH,MADG,CACtB,IADsB;AAAA,MAChB,GADgB,GACH,MADG,CAChB,GADgB;AAAA,MACX,GADW,GACH,MADG,CACX,GADW;;;AAG9B,MAAM,eAAe,eAAK,IAAL,CAAU,IAAV,EAAgB,MAAhB,EAAwB,OAAxB,CAArB;AACA,OAAK,cAAL,CAAoB,YAApB;;AAEA,OAAK,MAAL;AACA,MAAI,MAAJ;AACA,MAAI,MAAJ;;AAEA,SAAO,IAAP,CAAY,OAAZ,EAAqB;AAAA,WAAM,KAAK,QAAL,CAAc,EAAE,KAAK,QAAQ,GAAf,EAAd,CAAN;AAAA,GAArB;;AAEA,SAAO,EAAP,CAAU,OAAV,EAAmB,UAAC,GAAD,EAAS;AAC1B,YAAQ,KAAR,CAAc,GAAd;AACA,WAAO,KAAP;AACD,GAHD;AAID;;AAED,SAAS,qBAAT,CAAgC,GAAhC,EAAqC;AACnC;;;;;AAKA,MAAI,IAAI,OAAJ,KAAgB,iCAApB,EAAuD;AACrD,YAAQ,GAAR,CAAY,oBAAZ;;AAEA,oCAAO,GAAP,oBACG,IADH,CACQ;AAAA,aAAM,uDAAN;AAAA,KADR,EAEG,IAFH,CAEQ;AAAA,aAAY,KAAK,WAAL,EAAkB,QAAlB,CAAZ;AAAA,KAFR,EAGG,KAHH,CAGS;AAAA,aAAO,QAAQ,KAAR,CAAc,2BAAd,EAA2C,GAA3C,CAAP;AAAA,KAHT;;AAKA;AACA,oCAAO,IAAP,oBAAuB,UAAC,OAAD,EAAU,IAAV,EAAmB;AACxC,UAAI,OAAJ,EAAa;AACX,gBAAQ,KAAR,CAAc,sBAAd,EAAsC,OAAtC;AACD;;AAED,UAAI,KAAK,MAAL,GAAc,CAAlB,EAAqB;AACnB,gBAAQ,GAAR,CAAY,iBAAZ;;AAEA,YAAM,oBAAoB,KAAK,KAAL,CAAW,CAAX,CAA1B;;AAEA,gBAAQ,GAAR,CAAY,kBAAkB,GAAlB,CAAsB,UAAC,GAAD,EAAS;AAAA,cACjC,EADiC,GAC1B,GAD0B,CACjC,EADiC;;AAEzC,iBAAO,gCAAO,KAAP,CAAa,OAAO,MAAP,CAAc,EAAd,qBAA6B,EAAE,MAAF,EAA7B,CAAb,CAAP;AACD,SAHW,CAAZ;;AAKA;AACD;AACF,KAjBD;AAkBD,GA3BD,MA2BO;AACL,YAAQ,KAAR,CAAc,2BAAd,EAA2C,GAA3C;AACD;AACF;;AAED,wDAAkB,KAAK,IAAL,CAAU,IAAV,EAAgB,WAAhB,CAAlB,EACG,EADH,CACM,OADN,EACe,qBADf","file":"index.js","sourcesContent":["// @flow\nimport 'babel-polyfill';\nimport Chrome from 'chrome-remote-interface';\nimport { cdpConfig, sites } from './config';\nimport main from './src/main';\n\n// TODO: This is temporary\nconst site: TestSite = sites[0];\nconst fullOptions: Object = Object.assign({}, cdpConfig, site);\n\n/**\n * Driver wrapper for Chrome Remote Debugging Protocol.\n * Expects an inspectable instance of Chrome running (use `npm run chrome`).\n */\n\nfunction init (options, chrome) {\n  const { Page, DOM, CSS } = chrome;\n\n  const mainFunction = main.bind(null, chrome, options);\n  Page.loadEventFired(mainFunction);\n\n  Page.enable();\n  DOM.enable();\n  CSS.enable();\n\n  chrome.once('ready', () => Page.navigate({ url: options.url }));\n\n  chrome.on('error', (err) => {\n    console.error(err);\n    chrome.close();\n  });\n}\n\nfunction handleConnectionError (err) {\n  /**\n   * Most common connection failure is a leaking instance attached\n   * to the current tab. We want to open a new tab if so, and\n   * close the instance\n   */\n  if (err.message === 'Tab does not support inspection') {\n    console.log('Opening new tab...');\n\n    Chrome.New(cdpConfig)\n      .then(() => Chrome(cdpConfig))\n      .then(instance => init(fullOptions, instance))\n      .catch(err => console.error('Cannot connect to Chrome:', err));\n\n    // Close tabs if > 4 are open\n    Chrome.List(cdpConfig, (listErr, tabs) => {\n      if (listErr) {\n        console.error('Error fetching tabs:', listErr);\n      }\n\n      if (tabs.length > 4) {\n        console.log('Closing tabs...');\n\n        const allTabsButCurrent = tabs.slice(1);\n\n        Promise.all(allTabsButCurrent.map((tab) => {\n          const { id } = tab;\n          return Chrome.Close(Object.assign({}, cdpConfig, { id }));\n        }));\n\n        // console.log(JSON.stringify(tabs, null, 2));\n      }\n    });\n  } else {\n    console.error('Cannot connect to Chrome:', err);\n  }\n}\n\nChrome(cdpConfig, init.bind(null, fullOptions))\n  .on('error', handleConnectionError);\n"]}